22 serialization::archive 19 0 0 0 0 7 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 0 0 11 0 0 0 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 10 agilex_hps 36 intel_agilex_interface_generator_191 5 synth 59 agilex_hps_intel_agilex_interface_generator_191_r4euiwq.sdc 576 create_clock -name hps_user0_clk -period 20.0 [get_pins { hps_inst|s2f_module|s2f_user_clk0_hio }]
create_clock -name hps_user1_clk -period 8.0 [get_pins { hps_inst|s2f_module|s2f_user_clk1_hio }]
if {[get_collection_size [get_nodes  -nowarn hps_inst|s2f_module~l4_mp_clk ]] > 0} {
create_clock -name hps_l4_mp_clk_src -period 5.0 [get_nodes  hps_inst|s2f_module~l4_mp_clk]
create_generated_clock -divide_by 1 -name hps_l4_mp_clk [get_registers hps_inst|s2f_module~l4_mp_clk.reg] -master_clock [get_clocks hps_l4_mp_clk_src] -source [get_nodes hps_inst|s2f_module~l4_mp_clk]
} 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 44 emif_hps_altera_emif_arch_fm_191_hn5v4wi.sdc 52065 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing constraints of the memory device and
# of the memory interface

# ------------------------------------------- #
# -                                         - #
# --- Some useful functions and variables --- #
# -                                         - #
# ------------------------------------------- #

set script_dir [file dirname [info script]]
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_ip_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl"

#--------------------------------------------#
# -                                        - #
# --- Determine when SDC is being loaded --- #
# -                                        - #
#--------------------------------------------#

set syn_flow 0
set sta_flow 0
set fit_flow 0
set pow_flow 0
if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
   set syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
   set sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
   set fit_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_pow" } {
   set pow_flow 1
}
set ::io_only_analysis 0

# ------------------------ #
# -                      - #
# --- GENERAL SETTINGS --- #
# -                      - #
# ------------------------ #

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty

# Debug switch. Change to 1 to get more run-time debug information
set debug 0

# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_are_entity_names_on ]

# ---------------------- #
# -                    - #
# --- DERIVED TIMING --- #
# -                    - #
# ---------------------- #

# PLL multiplier to mem clk
regexp {([0-9\.]+) ps} $var(PLL_REF_CLK_FREQ_PS_STR) match var(PHY_REF_CLK_FREQ_PS)
regexp {([0-9\.]+) ps} $var(PLL_VCO_FREQ_PS_STR) match var(PHY_VCO_FREQ_PS)
set pll_multiplier [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(PHY_REF_CLK_FREQ_MHZ)] ]
set vco_multiplier [expr int($var(PHY_REF_CLK_FREQ_PS)/$var(PHY_VCO_FREQ_PS))]

# Half of memory clock cycle
set half_period [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [ expr $var(UI) / 2.0 ] ]

# Half of reference clock
set ref_period      [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [ expr $var(PHY_REF_CLK_FREQ_PS)/1000.0] ]
set ref_half_period [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [ expr $ref_period / 2.0 ] ]

# Other clock periods
set tCK_AFI     [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(USER_CLK_RATIO) ] ]
set tCK_C2P_P2C [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(C2P_P2C_CLK_RATIO) ] ]
set tCK_PHY     [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(PHY_HMC_CLK_RATIO) ] ]

# Asymmetric uncertainties on address and command paths
set ac_min_delay [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [ expr - $var(tIH) + $var(CA_TO_CK_BD_PKG_SKEW) ]]
set ac_max_delay [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [ expr   $var(tIS) + $var(CA_TO_CK_BD_PKG_SKEW) ]]

# ---------------------- #
# -                    - #
# --- INTERFACE RATE --- #
# -                    - #
# ---------------------- #

# -------------------------------------------------------------------- #
# -                                                                  - #
# --- This is the main call to the netlist traversal routines      --- #
# --- that will automatically find all pins and registers required --- #
# --- to apply timing constraints.                                 --- #
# --- During the fitter, the routines will be called only once     --- #
# --- and cached data will be used in all subsequent calls.        --- #
# -                                                                  - #
# -------------------------------------------------------------------- #

if { ! [ info exists emif_hps_altera_emif_arch_fm_191_hn5v4wi_sdc_cache ] } {
   emif_hps_altera_emif_arch_fm_191_hn5v4wi_initialize_ddr_db emif_hps_altera_emif_arch_fm_191_hn5v4wi_ddr_db var
   set emif_hps_altera_emif_arch_fm_191_hn5v4wi_sdc_cache 1
} else {
   if { $debug } {
      post_message -type info "SDC: reusing cached DDR DB"
   }
}

# ------------------------------------------------------------- #
# -                                                           - #
# --- If multiple instances of this core are present in the --- #
# --- design they will all be constrained through the       --- #
# --- following loop                                        --- #
# -                                                           - #
# ------------------------------------------------------------- #

set instances [ array names emif_hps_altera_emif_arch_fm_191_hn5v4wi_ddr_db ]
foreach { inst } $instances {
   if { [ info exists pins ] } {
      unset pins
   }
   array set pins $emif_hps_altera_emif_arch_fm_191_hn5v4wi_ddr_db($inst)

   # ----------------------- #
   # -                     - #
   # --- REFERENCE CLOCK --- #
   # -                     - #
   # ----------------------- #

   # First determine if a reference clock has already been created (i.e. Reference clock sharing)
   set ref_clock_exists [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_does_ref_clk_exist $pins(pll_ref_clock) ]
   if { $ref_clock_exists == 0 }  {
      # This is the reference clock used by the PLL to derive any other clock in the core
      create_clock -period "$var(PHY_REF_CLK_FREQ_MHZ)MHz" -waveform [ list 0 $ref_half_period ] $pins(pll_ref_clock) -add -name ${inst}_ref_clock
   }
   set pins(ref_clock_name) [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_clock_name_from_pin_name $pins(pll_ref_clock)]

   # ------------------ #
   # -                - #
   # --- PLL CLOCKS --- #
   # -                - #
   # ------------------ #

   # VCO clock
   #We also detect and save the index of the clocks that drive the CPAs
   set is_master [expr {([string compare $inst $pins(master_instname)] == 0) ? 1 : 0}]
   set i_vco_clock 0
   set i_cpa_clock_tile_pri -1
   set i_cpa_clock_tile_sec -1
   foreach { vco_clock } $pins(pll_vco_clock) {

      set suffix "_${i_vco_clock}"
      if {$vco_clock == $pins(master_vco_clock)} {
         set suffix ""
         if {$is_master} {
            set i_cpa_clock_tile_pri $i_vco_clock
         }
      } elseif {$vco_clock == $pins(master_vco_clock_sec)} {
         if {$is_master} {
            set i_cpa_clock_tile_sec $i_vco_clock
         }
      }

      set local_pll_vco_clk_${i_vco_clock} [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
         -target $vco_clock \
         -name "${inst}_vco_clk${suffix}" \
         -source $pins(pll_ref_clock) \
         -multiply_by [expr $vco_multiplier ]  \
         -divide_by 1 \
         -phase 0 ]
      incr i_vco_clock
   }
   
   if {! $var(IS_HPS)} {
      if {$is_master} {
         if {$i_cpa_clock_tile_pri == -1} {
            post_message -type critical_warning "Failed to find CPA clock index"
         }
         if {$i_cpa_clock_tile_sec == -1 && $var(PHY_PING_PONG_EN)} {
            post_message -type critical_warning "Failed to find CPA clock index for secondary interface"
         }
      }
   }

   # Core clocks
   set core_clocks [list]
   set core_clocks_local [list]

   # Skip if we're in HPS mode since there's no user accessible core clock
   # and there's no transfers within core fabric to analyze
   if {! $var(IS_HPS)} {

      set local_pll_master_vco_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
         -target $pins(master_vco_clock) \
         -name "${pins(master_instname)}_vco_clk" \
         -source $pins(pll_ref_clock) \
         -multiply_by [expr $vco_multiplier ]  \
         -divide_by 1 \
         -phase 0 ]

      # emif_usr_clk
      # Clock only exists when HMC is used.
      set local_core_usr_clock ""
      if {$pins(master_core_usr_clock) != ""} {
         set name "core_usr_clk"
         set master_core_clock $pins(master_core_usr_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_clock)
         lappend core_clocks_local $local_core_usr_clock 
      }
      
      # emif_usr_clk_sec
      # Clock only exists when ping-pong HMC is used
      set local_core_usr_clock_sec ""
      if {$pins(master_core_usr_clock_sec) != ""} {
         set name "core_usr_clk_sec"
         set master_core_clock_sec $pins(master_core_usr_clock_sec)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_clock_sec [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
            -target $master_core_clock_sec \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock_sec) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_clock_sec)
         lappend core_clocks_local $local_core_usr_clock_sec 
      }      

      # emif_usr_half_clk
      # Clock only exists when HMC is used and in 2x bridge mode
      set local_core_usr_half_clock ""
      if {$pins(master_core_usr_half_clock) != ""} {
         set name "core_usr_half_clk"
         set master_core_clock $pins(master_core_usr_half_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_half_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_half_clock)
         lappend core_clocks_local $local_core_usr_half_clock
      }
      
      # emif_usr_half_clk
      # Clock only exists when ping-pong HMC is used and in 2x bridge mode
      set local_core_usr_half_clock_sec ""
      if {$pins(master_core_usr_half_clock_sec) != ""} {
         set name "core_usr_half_clk_sec"
         set master_core_clock_sec $pins(master_core_usr_half_clock_sec)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_half_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
            -target $master_core_clock_sec \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock_sec) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_half_clock_sec)
         lappend core_clocks_local $local_core_usr_half_clock
      }      

      # afi_clk
      # Clock only exists when HMC isn't used.
      set local_core_afi_clock ""
      if {$pins(master_core_afi_clock) != ""} {
         set name "core_afi_clk"
         set master_core_clock $pins(master_core_afi_clock)
         if {$var(USER_CLK_RATIO) == 8} {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) / 2}]
         } else {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         }
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_afi_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_afi_clock)
         lappend core_clocks_local $local_core_afi_clock
      }

      # extra CPA output for PE test purpose.
      set local_core_dft_cpa_1_clock "" 
      if {$pins(master_core_dft_cpa_1_clock) != ""} {
         set name "core_dft_cpa_1_clk"
         set master_core_clock $pins(master_core_dft_cpa_1_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_dft_cpa_1_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_dft_cpa_1_clock)
         lappend core_clocks_local $local_core_dft_cpa_1_clock
      }
      
      # Calibration master logic clock
      if {$pins(master_cal_master_clk) != ""} {
         set pll_cal_master_clk [get_pins -nowarn $pins(master_cal_master_clk)]

         if {[get_collection_size $pll_cal_master_clk] > 0} {
            set name              "core_cal_master_clk"
            set master_core_clock $pins(master_cal_master_clk)
            set divide_by         $var(pll_c4_cnt) 
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_4) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c4_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_4)
            
            set local_cal_master_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]

            lappend core_clocks $pins(master_cal_master_clk)
            lappend core_clocks_local $local_cal_master_clock
         }
      }
      
      # Calibration slave logic clock
      if {$pins(master_cal_slave_clk) != ""} {
         set pll_cal_slave_clk [get_pins -nowarn $pins(master_cal_slave_clk)]

         if {[get_collection_size $pll_cal_slave_clk] > 0} {
            set name              "core_cal_slave_clk"
            set master_core_clock $pins(master_cal_slave_clk)
            set divide_by         $var(pll_c3_cnt) 
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_3) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c3_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_3)
            
            set local_cal_slave_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]

            lappend core_clocks $pins(master_cal_slave_clk)
            lappend core_clocks_local $local_cal_slave_clock
         }
      }

      # Optional PLL Extra clocks
      for {set i_extra_clk 0} {$i_extra_clk < $var(PLL_NUM_OF_EXTRA_CLKS)} {incr i_extra_clk} {
         set pll_extra_clk [get_pins -nowarn $pins(pll_extra_clk_${i_extra_clk})]

         # PLL counter may not exist if clock isn't actually connected and used
         if {[get_collection_size $pll_extra_clk] > 0} {
            set i_clk_cnt_num     [expr {$i_extra_clk + $var(pll_num_of_reserved_cnts)}]
            set name              "core_extra_clk_${i_extra_clk}"
            set master_core_clock $pins(pll_extra_clk_${i_extra_clk})
            set divide_by         $var(pll_c${i_clk_cnt_num}_cnt)
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_${i_clk_cnt_num}) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c${i_clk_cnt_num}_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_${i_clk_cnt_num})

            set local_pll_extra_clock [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]
         }
      }
   }

   # Periphery clocks
   set periphery_clocks [list]
   set i_phy_clock 0
   foreach { phy_clock } $pins(pll_phy_clock) {
      set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(PHY_HMC_CLK_RATIO)}]
      set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

      set local_phy_clk_${i_phy_clock} [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
         -target $phy_clock \
         -name "${inst}_phy_clk_${i_phy_clock}" \
         -source [lindex $pins(pll_vco_clock) $i_phy_clock] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_${i_phy_clock}]
      incr i_phy_clock
   }

   set i_phy_clock_l 0
   foreach { phy_clock_l } $pins(pll_phy_clock_l) {
      set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(C2P_P2C_CLK_RATIO)}]
      set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

      set local_phy_clk_l_${i_phy_clock_l} [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
         -target $phy_clock_l \
         -name "${inst}_phy_clk_l_${i_phy_clock_l}" \
         -source [lindex $pins(pll_vco_clock) $i_phy_clock_l] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_l_${i_phy_clock_l}]
      incr i_phy_clock_l
   }

   # ------------------------ #
   # -                      - #
   # --- WRITE FIFO CLOCK --- #
   # -                      - #
   # ------------------------ #

   set write_fifo_clk [get_keepers ${inst}*|tile_gen[*].lane_gen[*].lane_inst|lane_inst~out_phy_reg]

   set i_wf_clock 0
   foreach_in_collection wf_clock $write_fifo_clk {
      set vco_clock_id [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_vco_clk_id $wf_clock var]
      if {$vco_clock_id == -1} {
         post_message -type critical_warning "Failed to find VCO clock"
      } else {
         set local_wf_clk_${i_wf_clock} [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock \
           -target [get_node_info -name $wf_clock] \
           -name "${inst}_wf_clk_${i_wf_clock}" \
           -source [get_node_info -name $vco_clock_id] \
           -multiply_by 1 \
           -divide_by [expr $var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO)] \
           -phase 0 ]        
      }   
      incr i_wf_clock     
   }      

   # ---------------- #
   # -              - #
   # --- A/C PATH --- #
   # -              - #
   # ---------------- #

   # Only during the Fitter do we need to have constraints to allow for auto-delay chain code to
   # pick appropirate good settings
   # Also, only need it if address/command is not calibrated
   if {($fit_flow == 1) && ($var(CA_DESKEW) == 0)} {

      # First, define CK and CK#clocks because A/C timing is defined w.r.t. to these.
      set master_ck_clock ""
      foreach ac_clk_pin $pins(ac_clk) ac_clk_pin_n $pins(ac_clk_n) {
         set master_ck_clock [get_fanins $ac_clk_pin]
         foreach_in_collection check_pin $master_ck_clock {
            set check_pin_name [get_node_info -name $check_pin]
            if {[regexp {out_phy_reg$} $check_pin_name]} {
               set master_ck_clock $check_pin_name
               break
            }
         }
         create_generated_clock -multiply_by 1 -source $master_ck_clock $ac_clk_pin -name $ac_clk_pin     
         create_generated_clock -multiply_by 1 -invert -source $master_ck_clock $ac_clk_pin_n -name $ac_clk_pin_n     
      }
   
      foreach { ac_clk_pin } $pins(ac_clk) {
         # ac_pins can contain input ports such as mem_err_out_n
         # Loop through each ac pin to make sure we only apply set_output_delay to output ports
         foreach { ac_pin } $pins(ac_sync) {
            set ac_port [ get_ports $ac_pin ]
            if {[get_collection_size $ac_port] > 0} {
               if [ get_port_info -is_output_port $ac_port ] {
                  # Specifies the minimum delay difference between the DQS pin and the address/control pins:
                  set_output_delay -min $ac_min_delay -clock [get_clocks $ac_clk_pin] $ac_port -add_delay

                  # Specifies the maximum delay difference between the DQS pin and the address/control pins:
                  set_output_delay -max $ac_max_delay -clock [get_clocks $ac_clk_pin] $ac_port -add_delay
               }
            }
         }
      }
   } else {
      set_false_path -to $pins(ac_sync)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_sync)
   }


   # ----------------- #
   # -               - #
   # --- READ PATH --- #
   # -               - #
   # ----------------- #

   foreach { read_clock } $pins(rclk) {
      create_clock -period "$var(PHY_MEM_CLK_FREQ_MHZ)MHz" -waveform [ list 0 $half_period ] $read_clock -name ${read_clock}_IN -add
   }

   # ------------------------------ #
   # -                            - #
   # --- MULTICYCLE CONSTRAINTS --- #
   # -                            - #
   # ------------------------------ #
   
   if {!$var(IS_HPS)} {

      # Relax timing to the input of the synchronizer for the local_reset_req signal
      # setup=7 and hold=6 are somewhat arbitrary choices
      if {$is_master} {
         set tmp "${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|local_reset_req_sync_gen_master.local_reset_req_sync_inst|din_s1"
         set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
         set tmp_reg [get_registers -nowarn $tmp]
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }

      # Soft reset synchronizers
      # See RTL for the justification of setup=7 and hold=6
      set tmp "${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync*"
      set tmp_pin [get_pins -nowarn ${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync*|clrn]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold 6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }

      # seq2core_reset_done comes out of the PHY at up to 666MHz. Needs to be treated as async with synchronizer in the core.
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.seq2core_reset_done_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      
      
      # ac_parity_err 
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.seq2core_ac_parity_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }

      # afi_cal_in_progress (used by cal_counter module)
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_in_progress_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }
      
      # afi_cal_success
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_success_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      
      
      # afi_cal_fail
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_fail_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      

      # cal_counter synchronizer for global_reset_n_int
      set tmp "${inst}|arch|arch_inst|cal_counter_inst|non_hps.inst_sync_reset_n|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }
      
      # cal_counter synchronizer for afi_cal_in_progress
      set tmp "${inst}|arch|arch_inst|cal_counter_inst|non_hps.inst_sync_cal_in_progress|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      

      set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[6]]
      if {[get_collection_size $tmp] > 0} {
         set_multicycle_path -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through $tmp -from [get_keepers *reset*] -setup 3 -end
         set_multicycle_path -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through $tmp -from [get_keepers *reset*] -hold  2 -end
      }

      if {$var(PHY_USERMODE_OCT)} {
         set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19]]
         if {[get_collection_size $tmp] > 0} {
            set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.oct_cal_req_regs* -setup 4 -start
            set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.oct_cal_req_regs* -hold  3 -start
         }

         set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7]]
         if {[get_collection_size $tmp] > 0} {
            set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|regs.sr_out* -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7] -setup 4 -start
            set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|regs.sr_out* -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7] -hold  3 -start
         }
      }

      set ufi_wr [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ufi_write_reg]
      set ufi_rd [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ufi_read_reg]

      if {([get_collection_size $ufi_wr] > 0) && ([get_collection_size $ufi_rd] > 0)} {
         set_multicycle_path -from $ufi_wr -to $ufi_rd -setup 1 -end
         set_multicycle_path -from $ufi_wr -to $ufi_rd -hold  1 -end
      }
   }

   if {$var(AMM_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*amm_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(AMM_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*amm_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(MMR_C2P_UFI_MODE)!= "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*mmr_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(MMR_P2C_UFI_MODE)!= "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*mmr_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SEQ_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*seq_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*hmc_reg* -0.200
      }
   }
   if {$var(SEQ_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*seq_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*hmc_reg* -0.200
      }
   }
   if {$var(ECC_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ecc_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(ECC_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ecc_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(LANE_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*lane_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(LANE_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*lane_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SIDEBAND_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*sideband_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SIDEBAND_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*sideband_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   
   foreach periphery_clock $periphery_clocks {
      set_clock_uncertainty -10ps -add -enable_same_physical_edge -hold -from [get_clocks $periphery_clock] -to [get_clocks $periphery_clock]
   }

   if {!$var(IS_HPS)} {
      set dll_reset [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2]]
      if {[get_collection_size $dll_reset] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2] -setup 8 -end
            set_multicycle_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2] -hold  7 -end
         } else {
            set_false_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2]
         }
      }
   }

   # ------------------------------ #
   # -                            - #
   # --- FALSE PATH CONSTRAINTS --- #
   # -                            - #
   # ------------------------------ #

   if {$var(C2C_TG_FALSE_PATH)} {
      set_false_path -from tg|tg|* -to tg|tg|*
   }   

   
   foreach ac_buf_path [concat $var(PATTERNS_AC_CLK) $var(PATTERNS_AC_SYNC) $var(PATTERNS_AC_ASYNC)] {
     set length [string length $ac_buf_path]
     set last_char [string range $ac_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {

        set word_idx [string first "cal_oct" $ac_buf_path]
        if {$word_idx == -1 } {
            set word_idx [string first "no_oct" $ac_buf_path]
            set suffix "no_oct.obuf"
        } else {
            set suffix "cal_oct.obuf"
        }
        set sub_path [string range $ac_buf_path 0 [expr {$word_idx - 1}]]

        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"

        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }


   foreach ac_n_buf_path $var(PATTERNS_AC_CLK_N) {
     set length [string length $ac_n_buf_path]
     set last_char [string range $ac_n_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {

        set word_idx [string first "cal_oct" $ac_n_buf_path]
        if {$word_idx == -1 } {
            set word_idx [string first "no_oct" $ac_n_buf_path]
            set suffix "no_oct.obuf_bar"
        } else {
            set suffix "cal_oct.obuf_bar"
        }
        set sub_path [string range $ac_n_buf_path 0 [expr {$word_idx - 1}]]

        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"

        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }


   foreach dqdqs_buf_path [concat $var(PATTERNS_WCLK) $var(PATTERNS_WDATA) $var(PATTERNS_DBI) $var(PATTERNS_DM)] {
     set length [string length $dqdqs_buf_path]
     set last_char [string range $dqdqs_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {
        set word_idx [string first "cal_oct" $dqdqs_buf_path]
        set suffix "cal_oct.obuf"
        
        set sub_path [string range $dqdqs_buf_path 0 [expr {$word_idx - 1}]]
        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"
        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   } 

   foreach dqdqs_buf_path $var(PATTERNS_WCLK_N) {
     set length [string length $dqdqs_buf_path]
     set last_char [string range $dqdqs_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {
        set word_idx [string first "cal_oct" $dqdqs_buf_path]
        set suffix "cal_oct.obuf_bar"
        
        set sub_path [string range $dqdqs_buf_path 0 [expr {$word_idx - 1}]]
        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"
        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }

   # DQ/DQS pins are calibrated
   set_false_path -to $pins(wdata)
   set_false_path -from $pins(rdata)
   set_output_delay -clock $pins(ref_clock_name) 0 $pins(wdata)
   set_input_delay -clock $pins(ref_clock_name) 0 $pins(rdata)
   if {[llength $pins(dm)] > 0} {
      set_false_path -to $pins(dm)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dm)
   }
   if {[llength $pins(dbi)] > 0} {
      set_false_path -to $pins(dbi)
      set_false_path -from $pins(dbi)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dbi)
      set_input_delay -clock $pins(ref_clock_name) 0 $pins(dbi)
   }
   set_false_path -to $pins(wclk)
   set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk)
   if {[llength $pins(wclk_n)] > 0} {
      set_false_path -to $pins(wclk_n)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk_n)
   }
   set_false_path -from $pins(rclk)
   if {[llength $pins(rclk_n)] > 0} {
      set_false_path -from $pins(rclk_n)
   }
   if {[llength $pins(ac_clk)] > 0} {
      set_false_path -to $pins(ac_clk)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk) -add
   }
   if {[llength $pins(ac_clk_n)] > 0} {
      set_false_path -to $pins(ac_clk_n)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk_n) -add
   }

   if {[llength $pins(ac_async)] > 0} {
      set_false_path -to $pins(ac_async)
      set_false_path -from $pins(ac_async)
      foreach ac_async $pins(ac_async) {
         if {[get_port_info -is_input $ac_async] || [get_port_info -is_inout $ac_async]} {
            set_input_delay -clock $pins(ref_clock_name) 0 $ac_async
         }
         if {[get_port_info -is_output $ac_async] || [get_port_info -is_inout $ac_async]} {
            set_output_delay -clock $pins(ref_clock_name) 0 $ac_async
         }
      }
   }
   
   if {!$var(IS_HPS)} {
      set tmp_pins_0 [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core2dbc_rd_data_rdy]
      set tmp_pins_1 [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|dbc2core_rd_data_vld0]
      if {[get_collection_size $tmp_pins_0] > 0 && [get_collection_size $tmp_pins_1] > 0} {
         set_false_path -through $tmp_pins_0 -through $tmp_pins_1
      }
   }

   # ------------------------- #
   # -                       - #
   # --- CLOCK UNCERTAINTY --- #
   # -                       - #
   # ------------------------- #

   if {!$var(IS_HPS) && ($fit_flow == 1 || $sta_flow == 1)} {

      #################################
      # C2P/P2C transfers
      #################################

      # Get P2C / C2P Multi-tile clock uncertainty
      set p2c_c2p_multi_tile_clock_uncertainty [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_p2c_c2p_clock_uncertainty $inst var]

      # Get extra periphery clock uncertainty
      set periphery_clock_uncertainty [list]
      emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_periphery_clock_uncertainty periphery_clock_uncertainty var

      # Get Fitter overconstraints
      if {$fit_flow == 1} {
         emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_periphery_overconstraints periphery_overconstraints_st periphery_overconstraints_mt var
      } else {
         set periphery_overconstraints_st [list 0.0 0.0 0.0 0.0]
         set periphery_overconstraints_mt [list 0.0 0.0 0.0 0.0]
      }

      # Now loop over core/periphery clocks and set clock uncertainty
      set i_core_clock 0
      foreach core_clock $core_clocks {
         if {$core_clock != ""} {

            set local_core_clock [lindex $core_clocks_local $i_core_clock]
            
            if {$core_clock == $pins(master_core_usr_clock_sec) || $core_clock == $pins(master_core_usr_half_clock_sec)} {
               set same_tile_index $i_cpa_clock_tile_sec
            } else {
               set same_tile_index $i_cpa_clock_tile_pri
            }

            set i_phy_clock 0
            foreach { phy_clock } $pins(pll_phy_clock_l) {
               
               if {$i_phy_clock != $same_tile_index} {
                  # C2P/P2C where the periphery tile != CPA tile.
                  # For these transfers the SDC explicitly overrides the clock uncertainty values.
                  # Therefore, when overconstraining we must not use the "-add" option.
                  set add_to_derived ""
                  set c2p_su         [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 0] + [lindex $periphery_clock_uncertainty 0]}]
                  set c2p_h          [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 1] + [lindex $periphery_clock_uncertainty 1]}]
                  set p2c_su         [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 2] + [lindex $periphery_clock_uncertainty 2]}]
                  set p2c_h          [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 3] + [lindex $periphery_clock_uncertainty 3]}]
               } else {
                  # C2P/P2C where the periphery tile == CPA tile
                  # For these transfers it is safe to use the -add option since we rely on 
                  # derive_clock_uncertainty for the base value.
                  set add_to_derived "-add"
                  set c2p_su         [expr [lindex $periphery_overconstraints_st 0] + [lindex $periphery_clock_uncertainty 0]]
                  set c2p_h          [expr [lindex $periphery_overconstraints_st 1] + [lindex $periphery_clock_uncertainty 1]]
                  set p2c_su         [expr [lindex $periphery_overconstraints_st 2] + [lindex $periphery_clock_uncertainty 2]]
                  set p2c_h          [expr [lindex $periphery_overconstraints_st 3] + [lindex $periphery_clock_uncertainty 3]]
               }

               set catch_exception [catch {set local_phy_clk_l_${i_phy_clock}} result]
               if {$catch_exception == 0} {
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $c2p_su
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $c2p_h
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $p2c_su
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $p2c_h
                  
                  if {$sta_flow == 1 && $var(CUT_C2P_P2C_PATHS)} {
                     set_false_path -to [get_clocks [set local_phy_clk_l_${i_phy_clock}]] 
                     set_false_path -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] 
                  }
               }

               set catch_exception [catch {set local_phy_clk_${i_phy_clock}} result]
               if {$catch_exception == 0} {
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $c2p_su
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $c2p_h
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $p2c_su
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $p2c_h
                  
                  if {$sta_flow == 1 && $var(CUT_C2P_P2C_PATHS) } {
                     set_false_path -to [get_clocks [set local_phy_clk_${i_phy_clock}]] 
                     set_false_path -from [get_clocks [set local_phy_clk_${i_phy_clock}]] 
                  }
               
               }

               incr i_phy_clock
            }
         }
         incr i_core_clock
      }

      #################################
      # Within-core transfers
      #################################

      # Get extra core clock uncertainty
      set core_clock_uncertainty [list]
      emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_core_clock_uncertainty core_clock_uncertainty var

      # Get Fitter overconstraints
      if {$fit_flow == 1} {
         emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_core_overconstraints core_overconstraints var
      } else {
         set core_overconstraints [list 0.0 0.0 0.0 0.0]
      }

      set c2c_same_su         [expr [lindex $core_overconstraints 0] + [lindex $core_clock_uncertainty 0]]
      set c2c_same_h          [expr [lindex $core_overconstraints 1] + [lindex $core_clock_uncertainty 1]]
      set c2c_diff_su         [expr [lindex $core_overconstraints 2] + [lindex $core_clock_uncertainty 2]]
      set c2c_diff_h          [expr [lindex $core_overconstraints 3] + [lindex $core_clock_uncertainty 3]]

      # For these transfers it is safe to use the -add option of set_clock_uncertainty since
      # we rely on derive_clock_uncertainty for the base value.
      foreach src_core_clock_local $core_clocks_local {
         if {$src_core_clock_local != ""} {
            foreach dst_core_clock_local $core_clocks_local {
               if {$dst_core_clock_local != ""} {
                  if {$src_core_clock_local == $dst_core_clock_local} {
                     # Same clock network transfers
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -setup -add $c2c_same_su
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -hold -enable_same_physical_edge -add $c2c_same_h
                  } else {
                     # Transfers between different core clock networks
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -setup -add $c2c_diff_su
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -hold -add $c2c_diff_h
                  }
               }
            }
         }
      }

   }

   # --------------------- #
   # -                   - #
   # --- ACTIVE CLOCKS --- #
   # -                   - #
   # --------------------- #

   if {(($::quartus(nameofexecutable) ne "quartus_fit") && ($::quartus(nameofexecutable) ne "quartus_map"))} {

      if {$var(C2P_P2C_PR) && [llength $periphery_clocks] > 0 && !$debug} {
         post_sdc_message info "Setting periphery clocks as inactive; use Report DDR to timing analyze periphery clocks"
         set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $periphery_clocks]]
      }
   }
}

# -------------------------- #
# -                        - #
# --- REPORT DDR COMMAND --- #
# -                        - #
# -------------------------- #

add_ddr_report_command "source [list [file join [file dirname [info script]] ${::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename}_report_timing.tcl]]"

 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 58 emif_hps_altera_emif_arch_fm_191_hn5v4wi_ip_parameters.tcl 39852 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the memory device and
# of the memory interface

package require ::quartus::clock_uncertainty


set ::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename emif_hps_altera_emif_arch_fm_191_hn5v4wi

set var(PROTOCOL)                                                DDR4
set var(NUM_RANKS)                                               1
set var(SLEW_RATE_DRAM)                                          4.0
set var(SLEW_RATE_DRAM_CLOCK)                                    8.0
set var(VIN_Ms)                                                  0.136
set var(VIN_Mh)                                                  0.068
set var(SLEW_RATE_PHY)                                           2.0
set var(SLEW_RATE_PHY_CLOCK)                                     4.0
set var(SLEW_RATE_CA)                                            2.0
set var(SLEW_RATE_CLOCK)                                         4.0
set var(UI)                                                      0.833
set var(tCK)                                                     0.625
set var(tDQSQ)                                                   0.043750000000000004
set var(tQH)                                                     0.43
set var(tDS)                                                     0.04166666666666667
set var(tDH)                                                     0.04166666666666667
set var(tIS)                                                     0.04
set var(tIH)                                                     0.065
set var(tDQSCK)                                                  0.17
set var(tDQSS)                                                   0.27
set var(tWLS)                                                    0.108
set var(tWLH)                                                    0.108
set var(tDSS)                                                    0.18
set var(tDSH)                                                    0.18
set var(BD_PKG_SKEW)                                             0.02
set var(CA_BD_PKG_SKEW)                                          0.18
set var(CA_TO_CK_BD_PKG_SKEW)                                    0.0
set var(DQS_BOARD_SKEW)                                          0.02
set var(DQS_TO_CK_BOARD_SKEW)                                    0.02
set var(RD_ISI)                                                  0.075
set var(WR_ISI)                                                  0.09
set var(CA_ISI)                                                  0.15
set var(DQSG_ISI)                                                0.15
set var(WL_ISI)                                                  0.038
set var(X4)                                                      0
set var(IS_DLL_ON)                                               1
set var(OCT_RECAL)                                               1
set var(RDBI)                                                    1
set var(WDBI)                                                    1
set var(CUT_C2P_P2C_PATHS)                                       0
set var(CA_DESKEW)                                               1

set var(PHY_TARGET_SPEEDGRADE)                                   E2V
set var(PHY_TARGET_IS_ES)                                        false
set var(PHY_TARGET_IS_ES2)                                       false
set var(PHY_TARGET_IS_ES3)                                       true
set var(PHY_TARGET_IS_PRODUCTION)                                false
set var(PHY_CORE_CLKS_SHARING_ENUM)                              CORE_CLKS_SHARING_DISABLED
set var(PHY_CONFIG_ENUM)                                         CONFIG_PHY_AND_HARD_CTRL
set var(PHY_PING_PONG_EN)                                        false
set var(IS_HPS)                                                  true
set var(PHY_MEM_CLK_FREQ_MHZ)                                    1200.0
set var(PHY_REF_CLK_FREQ_MHZ)                                    100.0
set var(PHY_REF_CLK_JITTER_PS)                                   10.0
set var(PLL_REF_CLK_FREQ_PS_STR)                                 "10008 ps"
set var(PLL_VCO_FREQ_PS_STR)                                     "834 ps"
set var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO)                           1
set var(PLL_PHY_CLK_VCO_PHASE)                                   0
set var(USER_CLK_RATIO)                                          4
set var(C2P_P2C_CLK_RATIO)                                       4
set var(PHY_HMC_CLK_RATIO)                                       4
set var(MEM_FORMAT_ENUM)                                         MEM_FORMAT_DISCRETE
set var(MEM_DATA_MASK_EN)                                        true
set var(DIAG_TIMING_REGTEST_MODE)                                false
set var(DIAG_CPA_OUT_1_EN)                                       false
set var(DIAG_USE_CPA_LOCK)                                       true
set var(PHY_USERMODE_OCT)                                        false
set var(AMM_C2P_UFI_MODE)                                        pin_ufi_use_delay_fifo_out_reg
set var(AMM_P2C_UFI_MODE)                                        pin_ufi_use_fast_fifo_out_reg
set var(MMR_C2P_UFI_MODE)                                        pin_ufi_use_delay_fifo_out_reg
set var(MMR_P2C_UFI_MODE)                                        pin_ufi_use_fast_fifo_out_reg
set var(SIDEBAND_C2P_UFI_MODE)                                   pin_ufi_use_delay_fifo_out_reg
set var(SIDEBAND_P2C_UFI_MODE)                                   pin_ufi_use_fast_fifo_out_reg
set var(SEQ_C2P_UFI_MODE)                                        pin_ufi_use_delay_fifo_out_reg
set var(SEQ_P2C_UFI_MODE)                                        pin_ufi_use_fast_fifo_out_reg
set var(ECC_C2P_UFI_MODE)                                        pin_ufi_use_delay_fifo_out_reg
set var(ECC_P2C_UFI_MODE)                                        pin_ufi_use_fast_fifo_out_reg
set var(LANE_C2P_UFI_MODE)                                       pin_ufi_use_delay_fifo_out_reg
set var(LANE_P2C_UFI_MODE)                                       pin_ufi_use_fast_fifo_out_reg
set var(PLL_NUM_OF_EXTRA_CLKS)                                   0
set var(PLL_C_CNT_LOW_3)                                         2
set var(PLL_C_CNT_HIGH_3)                                        2
set var(PLL_C_CNT_BYPASS_EN_3)                                   false
set var(PLL_C_CNT_PHASE_PS_STR_3)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_3)                                  50
set var(PLL_C_CNT_LOW_4)                                         2
set var(PLL_C_CNT_HIGH_4)                                        2
set var(PLL_C_CNT_BYPASS_EN_4)                                   false
set var(PLL_C_CNT_PHASE_PS_STR_4)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_4)                                  50
set var(PLL_C_CNT_LOW_5)                                         256
set var(PLL_C_CNT_HIGH_5)                                        256
set var(PLL_C_CNT_BYPASS_EN_5)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_5)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_5)                                  50
set var(PLL_C_CNT_LOW_6)                                         256
set var(PLL_C_CNT_HIGH_6)                                        256
set var(PLL_C_CNT_BYPASS_EN_6)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_6)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_6)                                  50
set var(PLL_C_CNT_LOW_7)                                         256
set var(PLL_C_CNT_HIGH_7)                                        256
set var(PLL_C_CNT_BYPASS_EN_7)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_7)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_7)                                  50
set var(PLL_C_CNT_LOW_8)                                         256
set var(PLL_C_CNT_HIGH_8)                                        256
set var(PLL_C_CNT_BYPASS_EN_8)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_8)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_8)                                  50

set var(C2P_SETUP_OC_NS)                                         0.000
set var(C2P_HOLD_OC_NS)                                          0.000
set var(P2C_SETUP_OC_NS)                                         0.000
set var(P2C_HOLD_OC_NS)                                          0.000
set var(C2C_SAME_CLK_SETUP_OC_NS)                                0.000
set var(C2C_SAME_CLK_HOLD_OC_NS)                                 0.000
set var(C2C_DIFF_CLK_SETUP_OC_NS)                                0.000
set var(C2C_DIFF_CLK_HOLD_OC_NS)                                 0.000
set var(C2C_TG_FALSE_PATH)                                       false
set var(C2P_P2C_PR)                                              false

set var(PATTERNS_AC_CLK)                                         [list arch|arch_inst|bufs_inst|gen_mem_ck.inst[0].b|cal_oct.obuf|o]
set var(PATTERNS_AC_CLK_N)                                       [list arch|arch_inst|bufs_inst|gen_mem_ck.inst[0].b|cal_oct.obuf_bar|o]
set var(PATTERNS_AC_SYNC)                                        [list arch|arch_inst|bufs_inst|gen_mem_a.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_act_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_ba.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_ba.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_bg.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cke.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cs_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cs_n.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_odt.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_par.inst[0].b|cal_oct.obuf|o]
set var(PATTERNS_AC_ASYNC)                                       [list arch|arch_inst|bufs_inst|gen_mem_reset_n.inst[0].b|no_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_alert_n.inst[0].b|no_oct.ibuf|i]
set var(PATTERNS_RCLK)                                           [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_RCLK_N)                                         [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf_bar|o]
set var(PATTERNS_WCLK)                                           [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_WCLK_N)                                         [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf_bar|o]
set var(PATTERNS_RDATA)                                          [list arch|arch_inst|bufs_inst|gen_mem_dq.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[17].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[18].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[19].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[20].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[21].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[22].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[23].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[24].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[25].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[26].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[27].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[28].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[29].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[30].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[31].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[32].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[33].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[34].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[35].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[36].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[37].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[38].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[39].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[40].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[41].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[42].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[43].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[44].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[45].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[46].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[47].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[48].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[49].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[50].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[51].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[52].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[53].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[54].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[55].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[56].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[57].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[58].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[59].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[60].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[61].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[62].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[63].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[64].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[65].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[66].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[67].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[68].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[69].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[70].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[71].b|cal_oct.obuf|o]
set var(PATTERNS_WDATA)                                          [list arch|arch_inst|bufs_inst|gen_mem_dq.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[17].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[18].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[19].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[20].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[21].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[22].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[23].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[24].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[25].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[26].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[27].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[28].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[29].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[30].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[31].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[32].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[33].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[34].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[35].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[36].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[37].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[38].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[39].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[40].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[41].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[42].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[43].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[44].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[45].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[46].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[47].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[48].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[49].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[50].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[51].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[52].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[53].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[54].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[55].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[56].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[57].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[58].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[59].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[60].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[61].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[62].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[63].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[64].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[65].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[66].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[67].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[68].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[69].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[70].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[71].b|cal_oct.obuf|o]
set var(PATTERNS_DM)                                             [list ]
set var(PATTERNS_DBI)                                            [list arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_ALERT_N)                                        [list arch|arch_inst|bufs_inst|gen_mem_alert_n.inst[0].b|no_oct.ibuf|i]

initialize_clock_uncertainty_data
 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 55 emif_hps_altera_emif_arch_fm_191_hn5v4wi_parameters.tcl 1203 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the memory device and
# of the memory interface
# Note - this file is no longer used in Agilex and will be blank



 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 52 emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl 35672 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set script_dir [file dirname [info script]]
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_utils.tcl"

load_package sdc_ext

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_ddr_pins { instname allpins var_array_name} {
   # We need to make a local copy of the allpins associative array
   upvar allpins pins
   upvar 1 $var_array_name var
   set debug 0

   set var(pll_inclock_search_depth) 30
   set var(pll_outclock_search_depth) 20
   set var(pll_vcoclock_search_depth) 5

   # ########################################
   #  1.0 find all of the PLL output clocks


   set pll_c0_periph_clock_pin_name     "lvds_clk\[0\]"
   set pll_c1_periph_clock_pin_name     "loaden\[0\]"
   set vco_clock_pin_name               "vcoph\[0\]"

   #  C0 output in the periphery
   set pins(pll_c0_periph_clock) [list]
   set pins(pll_c0_periph_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$pll_c0_periph_clock_pin_name]]

   foreach_in_collection c $pins(pll_c0_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }
      lappend pins(pll_c0_periph_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(pll_c0_periph_clock) [emif_hps_altera_emif_arch_fm_191_hn5v4wi_sort_duplicate_names $pins(pll_c0_periph_clock)]

   #  C1 output in the periphery
   set pins(pll_c1_periph_clock) [list]
   set pins(pll_c1_periph_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$pll_c1_periph_clock_pin_name]]

   foreach_in_collection c $pins(pll_c1_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }

      lappend pins(pll_c1_periph_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(pll_c1_periph_clock) [emif_hps_altera_emif_arch_fm_191_hn5v4wi_sort_duplicate_names $pins(pll_c1_periph_clock)]

   #  VCO clock (used for the system clock)
   set pins(vco_clock) [list]
   set pins(vco_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$vco_clock_pin_name]]

   foreach_in_collection c $pins(vco_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }

      lappend pins(vco_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(vco_clock) [emif_hps_altera_emif_arch_fm_191_hn5v4wi_sort_duplicate_names $pins(vco_clock)]
   set pins(pll_vco_clock) $pins(vco_clock)
   set pins(pll_phy_clock) $pins(pll_c1_periph_clock)
   set pins(pll_phy_clock_l) $pins(pll_c0_periph_clock)

   if {$debug == 1} {
     puts "VCO:           $pins(pll_vco_clock)"
     puts "PHY:           $pins(pll_phy_clock)"
     puts "PHY_L:         $pins(pll_phy_clock_l)"
     puts ""
   }

   #########################################
   # 2.0  Find the actual master core clock
   #      As it could come from another interface
   #      In master/slave configurations
   #
   # Skip this if we're in HPS mode as core clocks don't exist
   
   set pins(master_vco_clock) ""
   set pins(master_vco_clock_sec) ""
   set pins(master_core_usr_clock) ""
   set pins(master_core_usr_half_clock) ""
   set pins(master_core_usr_clock_sec) ""
   set pins(master_core_usr_half_clock_sec) ""
   set pins(master_core_afi_clock) ""
   set pins(master_core_dft_cpa_1_clock) ""
   set pins(master_cal_master_clk) ""
   set pins(master_cal_slave_clk) ""
   
   if {$var(IS_HPS)} {
      set pins(master_instname) $instname

   } else {
      set msg_list [ list ]

      set num_of_cpa_blocks [expr {$var(PHY_PING_PONG_EN) ? 2 : 1}]

      for {set cpa_idx 0} {$cpa_idx < $num_of_cpa_blocks} {incr cpa_idx} {

         if {$cpa_idx == 0} {
            set sync_reset_reg ${instname}|arch|arch_inst|non_hps.core_clks_rsts_inst|reset_sync_pri_sdc_anchor
         } else {
            set sync_reset_reg ${instname}|arch|arch_inst|non_hps.core_clks_rsts_inst|pp.reset_sync_sec_sdc_anchor
         }

         set core_reset_sync_clock "_UNDEFINED_PIN_"
         set core_reset_sync_clock_id [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_output_clock_id $sync_reset_reg "Usr clock" msg_list var]
         if {$core_reset_sync_clock_id == -1} {
            foreach {msg_type msg} $msg_list {
               post_message -type $msg_type "emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl: $msg"
            }
            post_message -type error "emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl: Failed to find clock source for register $sync_reset_reg"

            if {$var(PHY_CORE_CLKS_SHARING_ENUM) == "CORE_CLKS_SHARING_SLAVE"} {
               post_message -type error "emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl: This is a clock sharing SLAVE interface. Please ensure that the clks_sharing_master_out port of the master is connected to the clks_sharing_master_in port of the slave(s)."
               if {$cpa_idx > 0} {
                  post_message -type error "emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl: This clock sharing slave interface uses a Ping-Pong PHY and has extra clock/reset requirements. Please ensure that the master interface is also a ping-pong interface. A ping-pong interface can act as clock sharing master for both ping-pong and non-ping-pong interfaces."
               }
            } else {
               post_message -type error "emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl: Please ensure that the register has not been removed or optimized away."
            }
         } else {
            set core_reset_sync_clock [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_pll_clock_name $core_reset_sync_clock_id]
         }

         if {[regexp {(^.*)\|arch\|arch_inst\|io_tiles_wrap_inst\|io_tiles_inst\|tile_gen\[([0-9])\].tile_ctrl_inst(.*)\|pa_core_clk_out\[[0-9]\]$} $core_reset_sync_clock matched pins(master_instname) tilegen_num tile_instnum] == 1} {
            if {$var(PHY_CONFIG_ENUM) == "CONFIG_PHY_AND_HARD_CTRL"} {
               if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
                  if {$cpa_idx == 0} {
                     set pins(master_core_usr_clock)          "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                     set pins(master_core_usr_half_clock)     "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
                  } else {
                     set pins(master_core_usr_clock_sec)      "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                     set pins(master_core_usr_half_clock_sec) "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
                  }
               } else {
                  if {$cpa_idx == 0} {
                     set pins(master_core_usr_clock)          "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                  } else {
                     set pins(master_core_usr_clock_sec)      "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                  }
               }
               set pins(master_core_dft_cpa_1_clock)   [expr {$var(DIAG_CPA_OUT_1_EN) ? "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]" : ""}]

            } else {
               set pins(master_core_afi_clock)             "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
            }

            if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn"} {
               set vco_clock_name "_UNDEFINED_PIN_"
            } else {
               set vco_clock_id [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_vco_clk_id $core_reset_sync_clock_id var]
               set vco_clock_name [get_net_info -name [get_pin_info -net $vco_clock_id]]
            }
            if {$cpa_idx == 0} {
               set pins(master_vco_clock) $vco_clock_name
            } else {
               set pins(master_vco_clock_sec) $vco_clock_name
            }

         } else {
            post_message -type error "emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl: Failed to find CPA outputs."
         }
      }

      if {!$var(DIAG_USE_CPA_LOCK)} {
         set pins(counter_lock_reg) $pins(master_instname)|arch|arch_inst|non_hps.core_clks_rsts_inst|counter_lock
      }

      set pll_master_user_clock_base [string range $pins(master_vco_clock) 0 [string last "|" $pins(master_vco_clock)] ]pll_inst|outclk

      set var(pll_c3_cnt) [emif_hps_altera_emif_arch_fm_191_hn5v4wi_calculate_counter_value $var(PLL_C_CNT_HIGH_3) $var(PLL_C_CNT_LOW_3) $var(PLL_C_CNT_BYPASS_EN_3)]
      set pins(master_cal_slave_clk) "$pll_master_user_clock_base\[3\]"

      set var(pll_c4_cnt) [emif_hps_altera_emif_arch_fm_191_hn5v4wi_calculate_counter_value $var(PLL_C_CNT_HIGH_4) $var(PLL_C_CNT_LOW_4) $var(PLL_C_CNT_BYPASS_EN_4)]
      set pins(master_cal_master_clk) "$pll_master_user_clock_base\[4\]"
   }

   if {$debug == 1} {
     puts "Master VCO                       : $pins(master_vco_clock)"
     puts "Master Core USR                  : $pins(master_core_usr_clock)"
     puts "Master Core USR Half             : $pins(master_core_usr_half_clock)"
     puts "Master Core AFI                  : $pins(master_core_afi_clock)"
     puts "Master VCO (SECONDARY)           : $pins(master_vco_clock_sec)"
     puts "Master Core USR (SECONDARY)      : $pins(master_core_usr_clock_sec)"
     puts "Master Core USR Half (SECONDARY) : $pins(master_core_usr_half_clock_sec)"
     puts ""
   }

   # ########################################
   #  2.5 Find the reference clock input of the PLL

   set pins(pll_cascade_in_id) [get_pins -nowarn -compatibility_mode $pins(master_instname)|arch|arch_inst|pll_inst|pll_inst|pll_cascade_in]
   if {[get_collection_size $pins(pll_cascade_in_id)] == 0} {
      set pins(pll_cascade_in_id) [get_pins -compatibility_mode $pins(master_instname)|arch|arch_inst|pll_inst|pll_inst|core_refclk]
   }
   set pll_ref_clock_id [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_input_clk_id $pins(pll_cascade_in_id) var]
   if {$pll_ref_clock_id == -1} {
      post_message -type critical_warning "emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl: Failed to find PLL reference clock"
   } else {
      set pll_ref_clock [get_node_info -name $pll_ref_clock_id]
   }
   set pins(pll_ref_clock) $pll_ref_clock

   if {$debug == 1} {
     puts "REF:     $pins(pll_ref_clock)"
     puts ""
   }

   #########################################
   # 3.0  find the FPGA pins

   # The hierarchy paths to all the pins are stored in the *_ip_parameters.tcl
   # file which is a generated file. Pins are divided into the following
   # protocol-agnostic categories. For each pin category, we need to
   # fully-resolve the hierarchy path patterns and store the results into
   # the "pins" arrays.

   set pin_categories [list ac_clk \
                            ac_clk_n \
                            ac_sync \
                            ac_async \
                            rclk \
                            rclk_n \
                            wclk \
                            wclk_n \
                            rdata \
                            wdata \
                            dm \
                            dbi ]

   set patterns [ list ]
   foreach pin_category $pin_categories {
      set pins($pin_category) [list]

      foreach pattern $var(PATTERNS_[string toupper $pin_category]) {
         set pattern "${instname}|$pattern"
         lappend patterns $pin_category $pattern
      }
   }

   foreach {pin_type pattern} $patterns {
      if {[string match "*|o" $pattern]} {
         set local_pins [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_names_in_collection [ get_fanouts $pattern ] ]
      } else {
         set local_pins [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_names_in_collection [ get_fanins $pattern ] ]
      }

      if {[llength $local_pins] == 0} {
         post_message -type critical_warning "Could not find pin of type $pin_type from pattern $pattern"
      } else {
         foreach pin [lsort -unique $local_pins] {
            lappend pins($pin_type) $pin
         }
      }
   }


   #########################################
   # 4.0  setup extra PLL clocks parameters

   # User can use remaining PLL clocks from EMIF GUI and this is to
   # setup the parameters for those clocks such as multiply_by
   # and divide_by

   if {$var(PLL_NUM_OF_EXTRA_CLKS) > 0} {

      set pll_master_user_clock_base [string range $pins(master_vco_clock) 0 [string last "|" $pins(master_vco_clock)] ]pll_inst|outclk

      set var(pll_num_of_reserved_cnts) 5

      for {set i 0} {$i < $var(PLL_NUM_OF_EXTRA_CLKS)} {incr i} {
         set i_cnt_num [expr $i + $var(pll_num_of_reserved_cnts)]
         set var(pll_c${i_cnt_num}_cnt) [emif_hps_altera_emif_arch_fm_191_hn5v4wi_calculate_counter_value $var(PLL_C_CNT_HIGH_${i_cnt_num}) $var(PLL_C_CNT_LOW_${i_cnt_num}) $var(PLL_C_CNT_BYPASS_EN_${i_cnt_num})]
         set pins(pll_extra_clk_${i}) "$pll_master_user_clock_base\[$i_cnt_num\]"
      }
   }
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_initialize_ddr_db { ddr_db_par var_array_name} {
   upvar $ddr_db_par local_ddr_db
   upvar 1 $var_array_name var

   global ::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename
   global ::io_only_analysis

   post_sdc_message info "Initializing DDR database for CORE $::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename"
   set instance_list [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_core_instance_list $::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename]

   foreach instname $instance_list {

      if {$::io_only_analysis == 0}  {
         post_sdc_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename INSTANCE: $instname"
         emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_ddr_pins $instname allpins var
         emif_hps_altera_emif_arch_fm_191_hn5v4wi_verify_ddr_pins allpins var
      }

      set local_ddr_db($instname) [ array get allpins ]
   }
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_verify_ddr_pins { pins_par var_array_name} {

   upvar 1 $var_array_name var
   upvar $pins_par pins

   if { [ llength $pins(pll_phy_clock) ] != [ llength $pins(pll_vco_clock) ] } {
      post_message -type critical_warning "Found different amounts of the phy_clocks compared to the vco_clocks"
   }
   if {!$var(IS_HPS)} {
      if {$var(PHY_CONFIG_ENUM) == "CONFIG_PHY_AND_HARD_CTRL"} {
         if { [ llength $pins(master_core_usr_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_usr_clock) ] of master_core_usr_clock when there should be 1"
         }

         if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
            if { [ llength $pins(master_core_usr_half_clock) ] != 1 } {
               post_message -type critical_warning "Found [ llength $pins(master_core_usr_half_clock) ] of master_core_usr_half_clock when there should be 1"
            }
         }

         if {$var(PHY_PING_PONG_EN)} {
            if { [ llength $pins(master_core_usr_clock_sec) ] != 1 } {
               post_message -type critical_warning "Found [ llength $pins(master_core_usr_clock_sec) ] of master_core_usr_clock_sec when there should be 1"
            }

            if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
               if { [ llength $pins(master_core_usr_half_clock_sec) ] != 1 } {
                  post_message -type critical_warning "Found [ llength $pins(master_core_usr_half_clock_sec) ] of master_core_usr_half_clock_sec when there should be 1"
               }
            }
         }
      } else {
         if { [ llength $pins(master_core_afi_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_afi_clock) ] of master_core_afi_clock when there should be 1"
         }
      }
   }
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_all_instances_dqs_pins { ddr_db_par } {
   upvar $ddr_db_par local_ddr_db

   set dqs_pins [ list ]
   set instnames [ array names local_ddr_db ]
   foreach instance $instnames {
      array set pins $local_ddr_db($instance)

      foreach { dqs_pin } $pins(dqs_pins) {
         lappend dqs_pins ${dqs_pin}_IN
         lappend dqs_pins ${dqs_pin}_OUT
      }
      foreach { dqsn_pin } $pins(dqsn_pins) {
         lappend dqs_pins ${dqsn_pin}_OUT
      }
      foreach { ck_pin } $pins(ck_pins) {
         lappend dqs_pins $ck_pin
      }
   }

   return $dqs_pins
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_calculate_counter_value { cnt_hi cnt_lo cnt_bypass } {
   if {$cnt_bypass} {
      set result 1
   } else {
      set result [expr {$cnt_hi + $cnt_lo}]
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_input_clk_id { pll_inclk_id var_array_name} {
   upvar 1 $var_array_name var

   array set results_array [list]

   emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_fanin_up_to_depth $pll_inclk_id emif_hps_altera_emif_arch_fm_191_hn5v4wi_is_node_type_pin clock results_array $var(pll_inclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find PLL clock for [get_node_info -name $pll_inclk_id]"
      set result -1
   }

   return $result
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_output_clock_id { pin_list pin_type msg_list_name var_array_name} {
   upvar 1 $msg_list_name msg_list
   upvar 1 $var_array_name var
   set output_clock_id -1

   set output_id_list [list]
   set pin_collection [get_keepers -no_duplicates $pin_list]
   if {[get_collection_size $pin_collection] == [llength $pin_list]} {
      foreach_in_collection id $pin_collection {
         lappend output_id_list $id
      }
   } elseif {[get_collection_size $pin_collection] == 0} {
      lappend msg_list "warning" "Could not find any $pin_type pins"
   } else {
      lappend msg_list "warning" "Could not find all $pin_type pins"
   }
   emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_pll_clock $output_id_list $pin_type output_clock_id $var(pll_outclock_search_depth)
   return $output_clock_id
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_pll_clock { dest_id_list node_type clock_id_name search_depth} {
   if {$clock_id_name != ""} {
      upvar 1 $clock_id_name clock_id
   }
   set clock_id -1

   array set clk_array [list]
   foreach node_id $dest_id_list {
      emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_fanin_up_to_depth $node_id emif_hps_altera_emif_arch_fm_191_hn5v4wi_is_node_type_pll_clk clock clk_array $search_depth
   }
   if {[array size clk_array] == 1} {
      set clock_id [lindex [array names clk_array] 0]
      set clk [get_node_info -name $clock_id]
   } elseif {[array size clk_array] > 1} {
      puts "Found more than 1 clock driving the $node_type"
      set clk ""
   } else {
      set clk ""
   }

   return $clk
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_vco_clk_id { wf_clock_id var_array_name} {
   upvar 1 $var_array_name var

   array set results_array [list]

   emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_fanin_up_to_depth $wf_clock_id emif_hps_altera_emif_arch_fm_191_hn5v4wi_is_node_type_vco clock results_array $var(pll_vcoclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find VCO clock for [get_node_info -name $wf_clock_id]"
      set result -1
   }

   return $result
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_is_node_type_pll_clk { node_id } {
   set cell_id [get_node_info -cell $node_id]

   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]

         if  {[regexp {pll_inst~.*OUTCLK[0-9]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } elseif {$atom_type == "TILE_CTRL"} {
         set node_name [get_node_info -name $node_id]

         if {[regexp {tile_ctrl_inst.*\|pa_core_clk_out\[[0-9]\]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_is_node_type_vco { node_id } {
   set cell_id [get_node_info -cell $node_id]

   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]

         if {[regexp {pll_inst.*\|.*vcoph\[0\]$} $node_name]} {
            set result 1
         } elseif {[regexp {pll_inst.*VCOPH0$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_does_ref_clk_exist { ref_clk_name } {

   set ref_clock_found 0
   foreach_in_collection iclk [get_clocks -nowarn] {
      if { ![is_clock_defined $iclk] } {
         continue
      }
      set clk_targets [get_clock_info -target $iclk]
      foreach_in_collection itgt $clk_targets {
         set node_name [get_node_info -name $itgt]
         if {[string compare $node_name $ref_clk_name] == 0} {
            set ref_clock_found 1
            break
         }
      }
      if {$ref_clock_found == 1} {
         break;
      }
   }

   return $ref_clock_found
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_p2c_c2p_clock_uncertainty { instname var_array_name } {

   set success 1
   set error_message ""
   set clock_uncertainty 0
   set debug 0

   package require ::quartus::atoms
   upvar 1 $var_array_name var

   catch {read_atom_netlist} read_atom_netlist_out
   set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]

   if {$read_atom_netlist_error == 0} {
      if {[emif_hps_altera_emif_arch_fm_191_hn5v4wi_are_entity_names_on]} {
         regsub -all {\|} $instname "|*:" instname
      }
      regsub -all {\\} $instname {\\\\} instname
      regsub -all {\[} $instname "\\\[" instname
      regsub -all {\]} $instname "\\\]" instname

      # Find the IOPLLs
      if {$success == 1} {
         if {[emif_hps_altera_emif_arch_fm_191_hn5v4wi_are_entity_names_on]} {
            set pll_atoms [get_atom_nodes -matching *${instname}|*:arch|*:arch_inst|*:pll_inst|* -type IOPLL]
         } else {
            set pll_atoms [get_atom_nodes -matching *${instname}|arch|arch_inst|pll_inst|* -type IOPLL]
         }
         set num_pll_inst [get_collection_size $pll_atoms]

         if {$num_pll_inst == 0} {
            set success 0
            post_message -type critical_warning "The auto-constraining script was not able to detect any PLLs in the < $instname > memory interface."
         }
      }

      # Get atom parameters
      if {$success == 1} {

         set mcnt_list [list]
         set bw_list   [list]
         set cp_setting_list [list]
         set vco_period_list [list]

         foreach_in_collection pll_atom $pll_atoms {

            # M-counter value
            if {[get_atom_node_info -node $pll_atom -key  BOOL_IOPLL_M_COUNTER_BYPASS_EN] == 1} {
               set mcnt 1
            } else {
               set mcnt [expr [get_atom_node_info -node $pll_atom -key INT_IOPLL_M_COUNTER_HIGH] + [get_atom_node_info -node $pll_atom -key INT_IOPLL_M_COUNTER_LOW]]
            }
            lappend mcnt_list $mcnt

            # BW
            set bw [get_atom_node_info -node $pll_atom -key  ENUM_IOPLL_BW_MODE]
            if {[string compare -nocase $bw "AUTO"] == 0} {
               set bw "LBW"
            } elseif  {[string compare -nocase $bw "LOW_BW"] == 0} {
                set bw "LBW"
            } elseif  {[string compare -nocase $bw "MID_BW"] == 0} {
                set bw "MBW"
            } elseif  {[string compare -nocase $bw "HI_BW"] == 0} {
                set bw "HBW"
            }
            lappend bw_list $bw

            # CP current setting (stubbed out for now as this is set internally)
            set cp_setting PLL_CP_SETTING0
            lappend cp_setting_list $cp_setting

            # VCO frequency setting
            set vco_period [get_atom_node_info -node $pll_atom -key TIME_IOPLL_VCO]
            lappend vco_period_list $vco_period
         }

         # Make sure all IOPLL parameters are the same
         for {set i [expr [llength $mcnt_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            if {[lindex $mcnt_list $i] != [lindex $mcnt_list [expr $i - 1]]} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $bw_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set bw_a [lindex $bw_list $i]
            set bw_b [lindex $bw_list [expr $i - 1]]
            if {[string compare -nocase $bw_a $bw_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $cp_setting_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set cp_a [lindex $cp_setting_list $i]
            set cp_b [lindex $cp_setting_list [expr $i - 1]]
            if {[string compare -nocase $cp_a $cp_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }

         for {set i [expr [llength $vco_period_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set vco_a [lindex $vco_period_list $i]
            set vco_b [lindex $vco_period_list [expr $i - 1]]
            if {[string compare -nocase $vco_a $vco_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
      }

      # Calculate clock uncertainty
      if {$success == 1} {

         set mcnt [lindex $mcnt_list 0]
         set bw   [string toupper [lindex $bw_list 0]]
         set cp_setting [lindex $cp_setting_list 0]
         set cp_current [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_cp_current_from_setting $cp_setting]
         set vco_period [lindex $vco_period_list 0]
         if {[regexp {([0-9]+) ps} $vco_period matched vco_period] == 1} {
         } else {
            post_message -type critical_warning "The auto-constraining script was not able to read the netlist."
            set success 0
         }
         set vco_frequency_in_mhz [expr 1000000 / $vco_period]

         if {$debug} {
            puts "MCNT : $mcnt"
            puts "BW   : $bw"
            puts "CP   : $cp_setting ($cp_current)"
            puts "VCO  : $vco_period"
         }

         set HFR  [get_clock_frequency_uncertainty_data PLL $vco_frequency_in_mhz $bw OFFSET${mcnt} HFR]
         set LFD  [get_clock_frequency_uncertainty_data PLL $vco_frequency_in_mhz $bw OFFSET${mcnt} LFD]
         set SPE  [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_spe_from_cp_current $cp_current]

         if {$success == 1} {
            set clock_uncertainty_sqrt  [expr sqrt(($LFD/2)*($LFD/2) + ($LFD/2)*($LFD/2))]
            set clock_uncertainty [emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp [expr ($clock_uncertainty_sqrt + $SPE)*1e9]]

            if {$debug} {
               puts "HFR  : $HFR"
               puts "LFD  : $LFD"
               puts "SPE  : $SPE"
               puts "TOTAL: $clock_uncertainty"
            }
         }
      }

   } else {
      set success 0
      post_message -type critical_warning "The auto-constraining script was not able to read the netlist."
   }

   # Output warning in the case that clock uncertainty can't be determined
   if {$success == 0} {
      post_message -type critical_warning "Verify the following:"
      post_message -type critical_warning " The core < $instname > is instantiated within another component (wrapper)"
      post_message -type critical_warning " The core is not the top-level of the project"
      post_message -type critical_warning " The memory interface pins are exported to the top-level of the project"
      post_message -type critical_warning " The core  < $instname > RTL has not been modified manually"
   }

   return $clock_uncertainty
}


proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_cp_current_from_setting { cp_setting } {

   set cp_current 0

   if {[string compare -nocase $cp_setting "PLL_CP_SETTING0"] == 0} {
      set cp_current 0
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING1"] == 0} {
      set cp_current 5	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING2"] == 0} {
      set cp_current 10
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING3"] == 0} {
      set cp_current 15
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING4"] == 0} {
      set cp_current 20	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING5"] == 0} {
      set cp_current 25		
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING6"] == 0} {
      set cp_current 30
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING7"] == 0} {
      set cp_current 35	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING8"] == 0} {
      set cp_current 40	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING9"] == 0} {
      set cp_current 45
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING10"] == 0} {
      set cp_current 50	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING11"] == 0} {
      set cp_current 55			
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING12"] == 0} {
      set cp_current 60
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING13"] == 0} {
      set cp_current 65			
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING14"] == 0} {
      set cp_current 70	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING15"] == 0} {
      set cp_current 75			
	} else {
      set cp_current 0
   }

   return $cp_current
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_spe_from_cp_current { cp_current } {

   set spe 158.0e-12

   if {$cp_current <= 15} {
      set spe 158e-012 
   } elseif {$cp_current <= 20} {
      set spe 130.62e-12 
   } elseif {$cp_current <= 25} {
      set spe 117.3e-12 
   } elseif {$cp_current <= 30} {
      set spe 109.5e-12 
   } elseif {$cp_current <= 35} {
      set spe 104.5e-12 
   } elseif {$cp_current <= 40} {
      set spe 100.9e-12 
   } elseif {$cp_current <= 60} {
      set spe 93.3e-12 
   } else {
      set spe 93.3e-12 
   }
   
   return $spe
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_periphery_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      set c2p_setup  0.050
      set c2p_hold   0.0
      set p2c_setup  0.050
      set p2c_hold   0.0
   } else {
      set c2p_setup  0.0
      set c2p_hold   0.0
      set p2c_setup  0.0
      set p2c_hold   0.0
   }

   set results [list $c2p_setup $c2p_hold $p2c_setup $p2c_hold]
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_core_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set c2c_same_setup  0
   set c2c_same_hold   0
   set c2c_diff_setup  0
   set c2c_diff_hold   0

   set results [list $c2c_same_setup $c2c_same_hold $c2c_diff_setup $c2c_diff_hold]
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_core_overconstraints { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set results [list $var(C2C_SAME_CLK_SETUP_OC_NS) $var(C2C_SAME_CLK_HOLD_OC_NS) $var(C2C_DIFF_CLK_SETUP_OC_NS) $var(C2C_DIFF_CLK_HOLD_OC_NS)]
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_periphery_overconstraints { results_st_array_name results_mt_array_name var_array_name } {
   upvar 1 $results_st_array_name results_st
   upvar 1 $results_mt_array_name results_mt
   upvar 1 $var_array_name var

   set c2p_p2c_frequency [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(C2P_P2C_CLK_RATIO)]

   set results_st [list $var(C2P_SETUP_OC_NS) $var(C2P_HOLD_OC_NS) $var(P2C_SETUP_OC_NS) $var(P2C_HOLD_OC_NS)]
   set results_mt [list [expr $var(C2P_SETUP_OC_NS) + 0.000] [expr $var(C2P_HOLD_OC_NS) + 0.000] [expr $var(P2C_SETUP_OC_NS) + 0.000] [expr $var(P2C_HOLD_OC_NS) + 0.000]]

}


proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_sort_duplicate_names { names_array } {

   set main_name ""
   set duplicate_names [list]

   # Find the main name as opposed to all the duplicate names
   foreach { name } $names_array {
      if  {[regexp {Duplicate} $name]} {
         lappend duplicate_names $name
      } else {
         if {$main_name == ""} {
            set main_name $name
         } else {
            post_message -type error "More than one main tile name ($main_name and $name).  Please verify the connectivity of these pins."
         }
      }
   }

   # Now sort the duplicate names
   set duplicate_names [lsort -decreasing $duplicate_names]

   # Prepend the main name and then return
   set result [join [linsert $duplicate_names 0 $main_name]]

   return $result
}

 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 61 emif_hps_altera_emif_arch_fm_191_hn5v4wi_report_io_timing.tcl 8089 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the routines to generate the early external memory
# interface timing report at the before the start of the compile flow.
#
# These routines are only meant to be used in this specific context.
# Trying to using them in a different context can have unexpected
# results.
#
# In performing the above timing analysis, the script
# calls procedures that are found in a separate file (report_timing_core.tcl)
# that has all the details of the timing analysis, and this
# file only serves as the top-level timing analysis flow.
#
# To reduce data lookups in all the procuedures that perform
# the individual timing analysis, data that is needed for
# multiple procedures is lookup up in this file and passed
# to the various parameters.  These data include both values
# that are applicable over all operating conditions, and those
# that are applicable to only one operating condition.
#
#############################################################

# Determin if only doing IO analysis
set ::io_only_analysis 1

#############################################################
# Initialize the environment / Error Checking
#############################################################

if { ![info exists quartus(nameofexecutable)] || $quartus(nameofexecutable) != "quartus_sta" } {
   post_message -type error "This script must be run from quartus_sta"
   return 1
}

# Check the project
if { ! [ is_project_open ] } {
   if { [ llength $quartus(args) ] > 0 } {
      set project_name [lindex $quartus(args) 0]
      project_open -revision [ get_current_revision $project_name ] $project_name
   } else {
      post_message -type error "Missing project_name argument"
      return 1
   }
}


# Load the timing netlist if required
if { ! [timing_netlist_exist] } {
   # In IO only flow, check to see if we could even create a timing nelist
   # First try to see if we could even create a
   catch {create_timing_netlist} create_timing_netlist_out
   set create_timing_netlist_error [regexp "ERROR" $create_timing_netlist_out]

   # If create timing netlist cannot run, then the IO flow is a valid flow
   if {$create_timing_netlist_error == 1} {
      create_emif_netlist -revision $::quartus(project)
      sta_create_empty_report
   } else {
      delete_timing_netlist
      post_message -type error "Early EMIF IO timing estimate cannot be run once the Fitter has been run"
      return 1
   }

} else {
   post_message -type error "Early EMIF IO timing estimate cannot be run once the Fitter has been run"
   return 1
}

# Load the reports
load_package report
set current_timing_report_type [get_current_report_type]
if { [catch {load_report_database -type_name $current_timing_report_type} load_report_out ] } {
   create_report_database -type_name $current_timing_report_type
}

#############################################################
# Some useful functions
#############################################################
set script_dir [file dirname [info script]]
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_ip_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_report_timing_core.tcl"


if [ info exists ddr_db ] {
   unset ddr_db
}
emif_hps_altera_emif_arch_fm_191_hn5v4wi_initialize_ddr_db ddr_db var


# If multiple instances of this core are present in the
# design they will all be analyzed through the
# following loop
set instances [ array names ddr_db ]
set inst_id 0
foreach inst $instances {

   if { [ info exists pins ] } {
      # Clean-up stale content
      unset pins
   }
   array set pins $ddr_db($inst)

   #################################################################################
   # Find some design values and parameters that will used during the timing analysis
   # that do not change accross the operating conditions

   set fname ""
   set fbasename ""
   if {[llength $instances] <= 1} {
      set fbasename "${::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename}"
   } else {
      set fbasename "${::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename}_${inst_id}"
   }

   #################################################################################
   # Now loop the timing analysis over the various operating conditions
   set summary [list]

   set opcname "All conditions"
   set opcname [string trim $opcname]

   #######################################
   # PHY Analyses

   emif_hps_altera_emif_arch_fm_191_hn5v4wi_perform_core_analysis $opcname $inst pins var summary

   #######################################
   # Print out the Summary Panel for this instance

   set summary [lsort -command emif_hps_altera_emif_arch_fm_191_hn5v4wi_sort_proc $summary]

   post_message -type info "Core: ${::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename} - Instance: $inst"
   post_message -type info "                                                         setup  hold"
   set panel_name "[get_report_folder -relative]||$inst"
   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }

   # Create summary panel
   set total_failures 0
   set rows [list]
   lappend rows "add_row_to_table -id \$panel_id \[list \"Path\" \"Operating Condition\" \"Setup Slack\" \"Hold Slack\"\]"
   foreach summary_line $summary {
      foreach {corner order path su hold num_su num_hold} $summary_line { }
      if {($num_su == 0) || ([string trim $su] == "")} {
         set su "--"
      }
      if {($num_hold == 0) || ([string trim $hold] == "")} {
         set hold "--"
      }


      if { ($su != "--" && $su < 0) || ($hold != "--" && $hold < 0) } {
         incr total_failures
         set type warning
         set offset 50
      } else {
         set type info
         set offset 53
      }
      if {$su != "--"} {
         set su [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp $su]
      }
      if {$hold != "--"} {
         set hold [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp $hold]
      }
      post_message -type $type [format "%-${offset}s | %6s %6s" $path $su $hold]
      set fg_colours [list black black]
      if { $su != "--" && $su < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }

      if { $hold != "" && $hold < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }
      lappend rows "add_row_to_table -id \$panel_id -fcolors \"$fg_colours\" \[list \"$path\" \"$corner\" \"$su\" \"$hold\"\]"
   }
   if {$total_failures > 0} {
      post_message -type critical_warning "DDR Timing requirements not met"
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   foreach row $rows {
      eval $row
   }

   incr inst_id
}
# end foreach inst


 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 58 emif_hps_altera_emif_arch_fm_191_hn5v4wi_report_timing.tcl 10042 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the routines to generate the external memory
# interface timing report at the end of the compile flow.
#
# These routines are only meant to be used in this specific context.
# Trying to using them in a different context can have unexpected
# results.
#
# In performing the above timing analysis, the script
# calls procedures that are found in a separate file (report_timing_core.tcl)
# that has all the details of the timing analysis, and this
# file only serves as the top-level timing analysis flow.
#
# To reduce data lookups in all the procuedures that perform
# the individual timing analysis, data that is needed for
# multiple procedures is lookup up in this file and passed
# to the various parameters.  These data include both values
# that are applicable over all operating conditions, and those
# that are applicable to only one operating condition.
#
#############################################################

# Determine if only doing IO analysis
set ::io_only_analysis 0

#############################################################
# Initialize the environment / Error Checking
#############################################################

proc get_speedgrade_from_opn {part} {
   set temp_grade [get_part_info -temperature_grade $part]
   set speed_grade [get_part_info -speed_grade $part]
   set power_model [get_part_info -power_model $part]

   if {$temp_grade == "Extended"} {
      set temp_grade "E"
   } elseif {$temp_grade == "Industrial"} {
      set temp_grade "I"
   } elseif {$temp_grade == "Commercial"} {
      set temp_grade "C"
   } else {
      set temp_grade [string index $part 12]
   }

   if {$power_model == "{Standard Power}"} { 
      set power_model "V"
   } elseif {$power_model == "{Lower Power}"} {
      set power_model "E"
   } elseif {$power_model == "{Extreme Low Power}"} {
      set power_model "X"
   } elseif {$power_model == "{Fixed Voltage}"} {
      set power_model "F"
   } else {
      set power_model [string index $part 14]
   }

   set retval $temp_grade
   append retval $speed_grade
   append retval $power_model
   return $retval
}

if { ![info exists quartus(nameofexecutable)] || $quartus(nameofexecutable) != "quartus_sta" } {
   post_message -type error "This script must be run from quartus_sta"
   return 1
}

# Check the project
if { ! [ is_project_open ] } {
   if { [ llength $quartus(args) ] > 0 } {
		set project_name [lindex $quartus(args) 0]
		project_open -revision [ get_current_revision $project_name ] $project_name
	} else {
		post_message -type error "Missing project_name argument"
		return 1
	}
}


# Load the timing netlist if required
if { ! [timing_netlist_exist] } {
   create_timing_netlist
   read_sdc
   update_timing_netlist

   set script_dir [file dirname [info script]]
   source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_ip_parameters.tcl"
   source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_parameters.tcl"
   source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl"
   source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_report_timing_core.tcl"
   if { ! [timing_netlist_exist] } {
      post_message -type error "Timing Netlist has not been created. Run the 'Update Timing Netlist' task first."
      return 1
   }
}


# Load the atom netlist if required
load_package atoms
read_atom_netlist

# Load the reports
load_package report
set current_timing_report_type [get_current_report_type]
load_report_database -type_name $current_timing_report_type

#############################################################
# Some useful functions
#############################################################
set script_dir [file dirname [info script]]
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_ip_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_pin_map.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_hn5v4wi_report_timing_core.tcl"

###############################################
# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to timing analyze the Core.

if [ info exists ddr_db ] {
   unset ddr_db
}
emif_hps_altera_emif_arch_fm_191_hn5v4wi_initialize_ddr_db ddr_db var

set old_active_clocks [get_active_clocks]
set_active_clocks [all_clocks]

# If multiple instances of this core are present in the
# design they will all be analyzed through the
# following loop
set instances [ array names ddr_db ]
set inst_id 0
foreach inst $instances {

   if { [ info exists pins ] } {
      # Clean-up stale content
      unset pins
   }
   array set pins $ddr_db($inst)

   #################################################################################
   # Find some design values and parameters that will used during the timing analysis
   # that do not change accross the operating conditions

   set fname ""
   set fbasename ""
   if {[llength $instances] <= 1} {
      set fbasename "${::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename}"
   } else {
      set fbasename "${::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename}_${inst_id}"
   }

   #################################################################################
   # Now loop the timing analysis over the various operating conditions
   set summary [list]

   set opcname [get_operating_conditions_info [get_operating_conditions] -display_name]
   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]
   set opcname [string trim $opcname]

   if {$hold_only_corner} {
      set opcname "${opcname}, Hold Only"
   }

   emif_hps_altera_emif_arch_fm_191_hn5v4wi_perform_core_analysis $opcname $inst pins var summary


   set summary [lsort -command emif_hps_altera_emif_arch_fm_191_hn5v4wi_sort_proc $summary]

   post_message -type info "Core: ${::GLOBAL_emif_hps_altera_emif_arch_fm_191_hn5v4wi_corename} - Instance: $inst"
   post_message -type info "                                                               setup  hold"
   set panel_name "[get_report_folder -relative]||$inst"
   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }

   # Create summary panel
   set total_failures 0
   set rows [list]
   lappend rows "add_row_to_table -id \$panel_id \[list \"Path\" \"Operating Condition\" \"Setup Slack\" \"Hold Slack\"\]"
   foreach summary_line $summary {
      foreach {corner order path su hold num_su num_hold} $summary_line { }
      if {($num_su == 0) || ([string trim $su] == "")} {
         set su "--"
      }
      if {($num_hold == 0) || ([string trim $hold] == "")} {
         set hold "--"
      }

      set type info
      set offset 59

      if { ($su != "--" && $su < 0) || ($hold != "--" && $hold < 0) } {
         incr total_failures
      }
      if {$su != "--"} {
         set su [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp $su]
      }
      if {$hold != "--"} {
         set hold [ emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp $hold]
      }
      post_message -type $type [format "%-${offset}s | %6s %6s" $path $su $hold]
      set fg_colours [list black black]
      if { $su != "--" && $su < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }

      if { $hold != "" && $hold < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }
      lappend rows "add_row_to_table -id \$panel_id -fcolors \"$fg_colours\" \[list \"$path\" \"$corner\" \"$su\" \"$hold\"\]"
   }
   if {$total_failures > 0} {
      post_message -type critical_warning "DDR Timing requirements not met"
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   foreach row $rows {
      eval $row
   }

   incr inst_id
}
# end foreach inst


set_active_clocks $old_active_clocks

set curr_part $::TimeQuestInfo(part)
set curr_speedgrade [get_speedgrade_from_opn $curr_part]

if {![test_part_trait_of $curr_part -trait FINAL_TIMING_MODEL]} {
   post_message -type critical_warning "Timing analysis was performed using a non-final timing model and/or constraints. You must regenerate the external memory interface IP and recheck timing closure in a future version of Quartus Prime."
}

if {$var(PHY_TARGET_SPEEDGRADE) == ""} {
   set effective_target_speedgrade "E1"
} else {
   set effective_target_speedgrade $var(PHY_TARGET_SPEEDGRADE)
}

if {$curr_speedgrade != $effective_target_speedgrade} {
   post_message -type critical_warning "This External Memory Interface IP core was generated for a speed grade $effective_target_speedgrade device, but the speed grade of $curr_part is $curr_speedgrade. You should regenerate the IP core to match the target device to avoid hardware issue."
}
 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 63 emif_hps_altera_emif_arch_fm_191_hn5v4wi_report_timing_core.tcl 12487 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.




################################################################
# Helper function to add a report_timing-based analysis section
################################################################
proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_add_report_timing_analysis {opcname inst var_array_name summary_name title from_clks to_clks from_nodes to_nodes } {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var

   set num_failing_path 10

   set setup_margin    999.9
   set hold_margin     999.9
   set recovery_margin 999.9
   set removal_margin  999.9

   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -setup]] > 0)} {
      set res_0        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (setup)" -setup]
      set setup_margin [lindex $res_0 1]
   } else {
      set setup_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -hold]] > 0} {
      set res_1        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (hold)" -hold]
      set hold_margin  [lindex $res_1 1]
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title ($opcname)" $setup_margin $hold_margin]
   }

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -recovery]] > 0)} {
      set res_0           [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (recovery)" -recovery]
      set recovery_margin [lindex $res_0 1]
   } else {
      set recovery_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -removal]] > 0} {
      set res_1           [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (removal)" -removal]
      set removal_margin  [lindex $res_1 1]
   } else {
      set removal_margin "--"
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title Recovery/Removal ($opcname)" $recovery_margin $removal_margin]
   }

   return [list $setup_margin $hold_margin $recovery_margin $removal_margin]
}

#############################################################
# Other Core-Logic related Timing Analysis
#############################################################

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_add_c2p_p2c_report_timing_analysis {opcname inst pin_array_name var_array_name summary_name title from_clks to_clks from_nodes to_nodes p2c} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   set num_failing_path 10

   set setup_margin    999.9
   set hold_margin     999.9
   set recovery_margin 999.9
   set removal_margin  999.9
   set debug 0

   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]

   set positive_fcolour [list "black" "blue" "blue"]
   set negative_fcolour [list "black" "red"  "red"]
   set summary [list]

   # Get the periphery clocks
   if {$p2c} {
      set phyclks $from_clks
   } else {
      set phyclks $to_clks
   }

   # Set panel names
   set panel_name_setup  "$inst $title (setup)"
   set panel_name_hold   "$inst $title (hold)"
   set panel_name_recovery  "$inst $title (recovery)"
   set panel_name_removal   "$inst $title (removal)"	
   set disable_panel_color_flag ""
   set quiet_flag ""

   # Generate the default margins
   if {!$hold_only_corner} {
      set res_0        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_setup -setup $disable_panel_color_flag $quiet_flag]
      set setup_margin [lindex $res_0 1]
   } else {
      set setup_margin "--"
   }
   set res_1        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_hold -hold $disable_panel_color_flag $quiet_flag]
   set hold_margin  [lindex $res_1 1]

   set recovery_paths 0
   set removal_paths 0

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -recovery]] > 0)} {
      set recovery_paths 1
      set res_2        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_recovery -recovery $disable_panel_color_flag $quiet_flag]
      set recovery_margin [lindex $res_2 1]
   } else {
      set recovery_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -removal]] > 0} {
      set removal_paths 1
      set res_3        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_removal  -removal  $disable_panel_color_flag $quiet_flag]
	   set removal_margin  [lindex $res_3 1]
   } else {
	   set removal_margin  "--"
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title ($opcname)" $setup_margin $hold_margin]
      if {($recovery_paths == 1) || ($removal_paths == 1)} {
         lappend global_summary [list $opcname 0 "$title Recovery/Removal ($opcname)" $recovery_margin $hold_margin]
      }
   }

   return [list $setup_margin $hold_margin $recovery_margin $removal_margin]
}


proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_perform_core_analysis {opcname inst pin_array_name var_array_name summary_name} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins
   global ::io_only_analysis

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0
   set result 1

   ###############################
   # PHY analysis
   ###############################

   set analysis_name "Core"

   if {$::io_only_analysis == 1} {
      set setup_slack "--"
      set hold_slack  "--"
      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_slack $hold_slack]
      post_message -type warning "Early EMIF IO timing estimate does not include core FPGA timing"
   } elseif {$var(IS_HPS)} {
      # No core timing analysis required by HPS interface
      set setup_slack "--"
      set hold_slack  "--"
      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_slack $hold_slack]
      lappend global_summary [list $opcname 0 "$analysis_name Recovery/Removal ($opcname)" $setup_slack $hold_slack]
   } else {

      set master_instname $pins(master_instname)
      set coreclkname [list ${master_instname}_core_usr_* ${master_instname}_core_afi_* ${master_instname}_core_dft_* ${master_instname}_ref_clock ${master_instname}_core_nios_clk [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_clock_name_from_pin_name $pins(pll_ref_clock)]]
      set coreclks [get_clocks -nowarn $coreclkname]

      set phyclkname [list ${inst}_phy_*]
      set phyclks [get_clocks -nowarn $phyclkname]

      set emif_regs [get_registers $inst|*]
      set rest_regs [remove_from_collection [all_registers] $emif_regs]

      set setup_margin    999.9
      set hold_margin     999.9
      set recovery_margin 999.9
      set removal_margin  999.9

      # Core/periphery transfers

      # Core-to-periphery
      set res [emif_hps_altera_emif_arch_fm_191_hn5v4wi_add_c2p_p2c_report_timing_analysis $opcname $inst $pin_array_name var global_summary "Core To Periphery" $coreclks $phyclks "*" $emif_regs 0]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Periphery-to-core
      set res [emif_hps_altera_emif_arch_fm_191_hn5v4wi_add_c2p_p2c_report_timing_analysis $opcname $inst $pin_array_name var global_summary "Periphery To Core" $phyclks $coreclks $emif_regs "*" 1]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Pure Core transfers

      set_active_clocks [remove_from_collection [all_clocks] $phyclks]

      # EMIF logic within FPGA core
      set res [emif_hps_altera_emif_arch_fm_191_hn5v4wi_add_report_timing_analysis $opcname $inst var global_summary "Within Core" $coreclks $coreclks $emif_regs $emif_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers between EMIF and user logic
      set res [emif_hps_altera_emif_arch_fm_191_hn5v4wi_add_report_timing_analysis $opcname $inst var global_summary "IP to User Logic" "*" "*" $emif_regs $rest_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers between user and EMIF logic
      set res [emif_hps_altera_emif_arch_fm_191_hn5v4wi_add_report_timing_analysis $opcname $inst var global_summary "User Logic to IP" "*" "*" $rest_regs $emif_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers within non-EMIF logic (not reported by default since they are irrelevant to EMIF IP)
      if {$var(DIAG_TIMING_REGTEST_MODE)} {
         set res [emif_hps_altera_emif_arch_fm_191_hn5v4wi_add_report_timing_analysis $opcname $inst var global_summary "Within User Logic" $coreclks $coreclks $rest_regs $rest_regs]
         set setup_margin    [min $setup_margin    [lindex $res 0]]
         set hold_margin     [min $hold_margin     [lindex $res 1]]
         set recovery_margin [min $recovery_margin [lindex $res 2]]
         set removal_margin  [min $removal_margin  [lindex $res 3]]
      }

      set_active_clocks [all_clocks]

      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_margin $hold_margin]
      lappend global_summary [list $opcname 0 "$analysis_name Recovery/Removal ($opcname)" $recovery_margin $removal_margin]
   }
}


 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 50 emif_hps_altera_emif_arch_fm_191_hn5v4wi_utils.tcl 19177 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.



set script_dir [file dirname [info script]]

load_package sdc_ext
load_package design

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_index_in_collection { col j } {
   set i 0
   foreach_in_collection path $col {
      if {$i == $j} {
         return $path
      }
      set i [expr $i + 1]
   }
   return ""
}


proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_clock_to_pin_name_mapping {} {
   set result [list]
   set clocks_collection [get_clocks]
   foreach_in_collection clock $clocks_collection {
      if { ![is_clock_defined $clock] } {
         continue
      }
      set clock_name [get_clock_info -name $clock]
      set clock_target [get_clock_info -targets $clock]
      set first_index [emif_hps_altera_emif_arch_fm_191_hn5v4wi_index_in_collection $clock_target 0]
      set catch_exception_net [catch {get_net_info -name $first_index} pin_name_net]
      if {$catch_exception_net == 0} {
         lappend result [list $clock_name $pin_name_net]
      } else {
         set catch_exception_port [catch {get_port_info -name $first_index} pin_name_port]
         if {$catch_exception_port == 0} {
            lappend result [list $clock_name $pin_name_port]
         } else {
            set catch_exception_reg [catch {get_register_info -name $first_index} pin_name_reg]
            if {$catch_exception_reg == 0} {
               lappend result [list $clock_name $pin_name_reg]
            } else {
               set catch_exception_pin [catch {get_pin_info -name $first_index} pin_name_pin]
               if {$catch_exception_pin == 0} {
                  lappend result [list $clock_name $pin_name_pin]
               }
            }
         }
      }
   }
   return $result
}


proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_clock_name_from_pin_name { pin_name } {
   set table [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_clock_to_pin_name_mapping]
   foreach entry $table {
      if {[string compare [lindex [lindex [split $entry] 1] 0] $pin_name] == 0} {
         return [lindex $entry 0]
      }
   }
   return ""
}



proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_find_all_keepers { mystring } {
   set allkeepers [get_keepers $mystring ]

   foreach_in_collection keeper $allkeepers {
      set keepername [ get_node_info -name $keeper ]

      puts "$keepername"
   }
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_round_3dp { x } {
   return [expr { round($x * 1000) / 1000.0  } ]
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_current_timequest_report_folder {} {

   set catch_exception [catch {get_current_timequest_report_folder} error_message]
   if {[regexp ERROR $error_message] == 1} {
      return "ReportDDR"
   } else {
      return [get_current_timequest_report_folder]
   }
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_timequest_name {hier_name} {
   set sta_name $hier_name
   return $sta_name
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_are_entity_names_on { } {
   return [set_project_mode -is_show_entity]
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_core_instance_list {corename} {
   global ::io_only_analysis

   if {$::io_only_analysis == 1}  {
      set instance_list [list $corename]

   } else {
      set full_instance_list [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_core_full_instance_list $corename]
      set instance_list [list]

      foreach inst $full_instance_list {
         set sta_name [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_timequest_name $inst]
         if {[lsearch $instance_list [escape_brackets $sta_name]] == -1} {
            lappend instance_list $sta_name
         }
      }

   }
   return $instance_list
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_or_add_generated_clock {args} {
   array set opts [list -name "" -target "" -source "" -multiply_by 1 -divide_by 1 -phase 0]
   array set opts $args

   set multiply_by [expr int($opts(-multiply_by))]
   if {[expr $multiply_by - $opts(-multiply_by)] != 0.0} {
      post_message -type error "Specify an integer ranging from 0 to 99999999 for the option -multiply_by"
      return ""
   }

   set clock_name [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_clock_name_from_pin_name $opts(-target)]

   if {[string compare -nocase $clock_name ""] == 0} {
      set nets [get_nets $opts(-target) -nowarn]
      if {[get_collection_size $nets] > 0} {
         set pin_name [get_pin_info -name [get_net_info -pin $nets]]
         set clock_name [emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_clock_name_from_pin_name $pin_name]

         if {[string compare -nocase $clock_name ""] != 0} {
            if {[regexp -nocase "lvds_clk" $pin_name] || [regexp -nocase "loaden" $pin_name] } {
               remove_clock $clock_name
               set clock_name ""
            }
          }
       }
   } else {
      if {([string compare -nocase $opts(-name) ""] != 0) && ([string compare -nocase $opts(-name) $clock_name])} {

         if {[regexp -nocase "pll_inst\|outclk" $opts(-target)]} {
            remove_clock $clock_name
            set clock_name ""
         }
      }
   }

   if {[string compare -nocase $clock_name ""] == 0} {
      set clock_name $opts(-name)

      create_generated_clock \
         -name $clock_name \
         -source $opts(-source) \
         -multiply_by $multiply_by \
         -divide_by $opts(-divide_by) \
         -phase $opts(-phase) \
         $opts(-target)
   }

   return $clock_name
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_core_full_instance_list {corename} {

   set instance_list [list]

   if {[is_fitter_in_qhd_mode]} {
      set instance_list_pre [design::get_instances -entity $corename]

   } else {
      set instance_list_pre [get_entity_instances $corename]
   }

   foreach instance $instance_list_pre {
      regsub {\|arch$} $instance "" instance_no_arch
      lappend instance_list $instance_no_arch
   }

   if {[ llength $instance_list ] == 0} {
      post_message -type error "The auto-constraining script was not able to detect any instance for core < $corename >"
      post_message -type error "Make sure the core < $corename > is instantiated within another component (wrapper)"
      post_message -type error "and it's not the top-level for your project"
   }

   return $instance_list
}


proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
   upvar 1 $results_array_name results

   if {$depth < 0} {
      error "Internal error: Bad timing netlist search depth"
   }
   set fanin_edges [get_node_info -${edge_type}_edges $node_id]
   set number_of_fanin_edges [llength $fanin_edges]
   for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
      set fanin_edge [lindex $fanin_edges $i]
      set fanin_id [get_edge_info -src $fanin_edge]
      if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
         set results($fanin_id) 1
      } elseif {$depth == 0} {
      } else {
         emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
      }
   }
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_is_node_type_pin { node_id } {
   set node_type [get_node_info -type $node_id]
   if {$node_type == "port"} {
      set result 1
   } else {
      set result 0
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_pll_clock_name { clock_id } {
   set clock_name [get_node_info -name $clock_id]

   return $clock_name
}

proc post_sdc_message {msg_type msg} {
   global ::io_only_analysis

   if {($::io_only_analysis == 1) || $::TimeQuestInfo(nameofexecutable) != "quartus_fit"} {
      post_message -type $msg_type $msg
   }
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_names_in_collection { col } {
   set res [list]
   foreach_in_collection node $col {
      lappend res [ get_node_info -name $node ]
   }
   return $res
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_format_3dp { x } {
   return [format %.3f $x]
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_colours { x y } {

   set fcolour [list "black"]
   if {$x < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }
   if {$y < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }

   return $fcolour
}

proc min { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a < $b } {
      return $a
   } else {
      return $b
   }
}

proc max { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a > $b } {
      return $a
   } else {
      return $b
   }
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_max_in_collection { col attribute } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set max [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp > $max} {
            set max $temp
         }
      }
      set i [expr $i + 1]
   }
   return $max
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_min_in_collection { col attribute } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set min [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp < $min} {
            set min $temp
         }
      }
      set i [expr $i + 1]
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_min_in_collection_to_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -to_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_min_in_collection_from_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -from_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_min_in_collection_to_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_min_in_collection_from_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_max_in_collection_to_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_max_in_collection_from_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}


proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_min_in_collection_to_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_min_in_collection_from_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_max_in_collection_to_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_max_in_collection_from_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_sort_proc {a b} {
   set idxs [list 1 2 0]
   foreach i $idxs {
      set ai [lindex $a $i]
      set bi [lindex $b $i]
      if {$ai > $bi} {
         return 1
      } elseif { $ai < $bi } {
         return -1
      }
   }
   return 0
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_gcd {p q} {
   set p [expr {abs($p)}]
   set q [expr {abs($q)}]
   while {$q != 0} {
      set r [expr {$p % $q}]
      set p $q
      set q $r
   }
   return $p
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_atom_path {atom_id atom_oport_id path} {
   # Return list of {atom oterm_id} pairs by tracing the atom netlist starting from the given atom_id through the given path
   # Path consists of list of {atom_type fanin|fanout|end <port_type> <-optional>}
   set result [list]
   if {[llength $path] > 0} {
      set path_point [lindex $path 0]
      set atom_type [lindex $path_point 0]
      set next_direction [lindex $path_point 1]
      set port_type [lindex $path_point 2]
      set atom_optional [lindex $path_point 3]
      if {[get_atom_node_info -key type -node $atom_id] == $atom_type} {
         if {$next_direction == "end"} {
            if {[get_atom_port_info -key type -node $atom_id -port_id $atom_oport_id -type oport] == $port_type} {
               lappend result [list $atom_id $atom_oport_id]
            }
         } elseif {$next_direction == "atom"} {
            lappend result [list $atom_id]
         } elseif {$next_direction == "fanin"} {
            set atom_iport [get_atom_iport_by_type -node $atom_id -type $port_type]
            if {$atom_iport != -1} {
               set iport_fanin [get_atom_port_info -key fanin -node $atom_id -port_id $atom_iport -type iport]
               set source_atom [lindex $iport_fanin 0]
               set source_oterm [lindex $iport_fanin 1]
               set result [emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_atom_path $source_atom $source_oterm [lrange $path 1 end]]
            } elseif {$atom_optional == "-optional"} {
               set result [emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
            }
         } elseif {$next_direction == "fanout"} {
            set atom_oport [get_atom_oport_by_type -node $atom_id -type $port_type]
            if {$atom_oport != -1} {
               set oport_fanout [get_atom_port_info -key fanout -node $atom_id -port_id $atom_oport -type oport]
               foreach dest $oport_fanout {
                  set dest_atom [lindex $dest 0]
                  set dest_iterm [lindex $dest 1]
                  set fanout_result_list [emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_atom_path $dest_atom -1 [lrange $path 1 end]]
                  foreach fanout_result $fanout_result_list {
                     if {[lsearch $result $fanout_result] == -1} {
                        lappend result $fanout_result
                     }
                  }
               }
            }
         } else {
            error "Unexpected path"
         }
      } elseif {$atom_optional == "-optional"} {
         set result [emif_hps_altera_emif_arch_fm_191_hn5v4wi_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
      }
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_hn5v4wi_get_operating_conditions_number {} {
   set cur_operating_condition [get_operating_conditions]
   set counter 0
   foreach_in_collection op [get_available_operating_conditions] {
      if {[string compare $cur_operating_condition $op] == 0} {
         return $counter
      }
      incr counter
   }
   return $counter
}
 13 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 2 ip 11 qsys_top_r1 18 user_rst_clkgate_0 32 altera_s10_user_rst_clkgate_1941 5 synth 34 altera_s10_user_rst_clkgate_fm.sdc 1177 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#Create base clock with 100 MHz targetted for internal clocks listed below

#Agilex
#auto_fab_0|alt_sld_fab_0|alt_sld_fab_0|agilexconfigreset|user_reset|sdm_gpo_out_user_reset~internal_ctrl_clock.reg


create_clock -name {internal_clk} -period 10.000 -waveform {0.000 5.000} { auto_fab*|*|*sdm_gpo_out_user_reset~internal_ctrl_clock }

set_clock_groups -asynchronous -group [get_clocks {internal_clk}]



 11 0 1 / 4 home 5 wisig 6 Videos 7 gokul_2 7 quartus 2 G3 11 qsys_top_r1 28 altera_reset_controller_1921 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 0
